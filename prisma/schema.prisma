generator client {
  provider = "prisma-client"
  output = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// =============================================================================
// ANIME & RELATED MODELS
// =============================================================================

model Anime {
  id             Int     @id
  title          String
  description    String?
  image          String?
  type           String?
  episodes       String?
  status         String?
  premiered      String?
  releasedSeason String?
  releasedYear   Float?
  source         String?
  duration       String?
  rating         String?
  score          Float?
  ranked         String?
  popularity     String?
  members        String?
  favorites      String?
  characters     Json?
  sourceUrl      String?

  // Normalized relationships
  animeGenres    AnimeGenre[]
  animeThemes    AnimeTheme[]
  animeStudios   AnimeStudio[]
  animeProducers AnimeProducer[]
  demographicRef Demographic?    @relation(fields: [demographicId], references: [id])
  demographicId  Int?

  // Game relationships
  dailySchedules DailySchedule[]

  @@index([score])
  @@index([releasedYear])
  @@index([title])
}

// =============================================================================
// NORMALIZED LOOKUP TABLES
// =============================================================================

model Studio {
  id             Int             @id @default(autoincrement())
  name           String          @unique
  animes         AnimeStudio[]
  dailySchedules DailySchedule[]

  @@index([name])
}

model Genre {
  id     Int          @id @default(autoincrement())
  name   String       @unique
  animes AnimeGenre[]
  cards  AnimeCard[]  @relation("AnimeCardToGenre")
  mangas Manga[]      @relation("GenreToManga")

  @@index([name])
}

model Theme {
  id     Int          @id @default(autoincrement())
  name   String       @unique
  animes AnimeTheme[]

  @@index([name])
}

model Producer {
  id     Int             @id @default(autoincrement())
  name   String          @unique
  animes AnimeProducer[]

  @@index([name])
}

model Demographic {
  id     Int     @id @default(autoincrement())
  name   String  @unique
  animes Anime[]

  @@index([name])
}

// =============================================================================
// JUNCTION TABLES FOR MANY-TO-MANY RELATIONSHIPS
// =============================================================================

model AnimeGenre {
  animeId Int
  genreId Int
  anime   Anime @relation(fields: [animeId], references: [id], onDelete: Cascade)
  genre   Genre @relation(fields: [genreId], references: [id], onDelete: Cascade)

  @@id([animeId, genreId])
  @@index([genreId])
}

model AnimeTheme {
  animeId Int
  themeId Int
  anime   Anime @relation(fields: [animeId], references: [id], onDelete: Cascade)
  theme   Theme @relation(fields: [themeId], references: [id], onDelete: Cascade)

  @@id([animeId, themeId])
  @@index([themeId])
}

model AnimeStudio {
  animeId  Int
  studioId Int
  anime    Anime  @relation(fields: [animeId], references: [id], onDelete: Cascade)
  studio   Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)

  @@id([animeId, studioId])
  @@index([studioId])
}

model AnimeProducer {
  animeId    Int
  producerId Int
  anime      Anime    @relation(fields: [animeId], references: [id], onDelete: Cascade)
  producer   Producer @relation(fields: [producerId], references: [id], onDelete: Cascade)

  @@id([animeId, producerId])
  @@index([producerId])
}

// =============================================================================
// DAILY GAME SCHEDULE (CONSOLIDATED)
// =============================================================================
// Game types: 'wordle', 'banner', 'studio'

model DailySchedule {
  id       Int      @id @default(autoincrement())
  date     DateTime
  gameType String   // 'wordle', 'banner', 'studio'

  // Target references (one will be set based on gameType)
  animeId  Int?
  studioId Int?
  anime    Anime?   @relation(fields: [animeId], references: [id])
  studio   Studio?  @relation(fields: [studioId], references: [id])

  @@unique([date, gameType])
  @@index([date])
  @@index([gameType])
  @@index([animeId])
  @@index([studioId])
}

// =============================================================================
// GAME SESSION (CONSOLIDATED)
// =============================================================================
// Game types: 'wordle', 'banner', 'studio'

model GameSession {
  id        String      @id @default(cuid())
  userId    String
  gameType  String      // 'wordle', 'banner', 'studio'
  date      DateTime    @default(now())
  targetId  String      // animeId (as string) for wordle/banner, studioName for studio
  won       Boolean     @default(false)
  failed    Boolean     @default(false)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  guesses   GameGuess[]

  @@unique([userId, date, gameType])
  @@index([userId])
  @@index([date])
  @@index([gameType])
}

// =============================================================================
// GAME GUESS (CONSOLIDATED)
// =============================================================================
// guessData format varies by game type:
//   - wordle: { animeId, title, ... comparison data }
//   - banner: { animeId }
//   - studio: { studioName }

model GameGuess {
  id        String      @id @default(cuid())
  sessionId String
  guessData Json        // Flexible storage for any guess type
  createdAt DateTime    @default(now())
  session   GameSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
}

// =============================================================================
// GAME STATISTICS
// =============================================================================

model GameStats {
  id           String    @id @default(cuid())
  userId       String
  gameType     String
  wins         Int       @default(0)
  lastWonAt    DateTime?
  totalTries   Int       @default(0)
  dailyGuesses Int       @default(0)
  lastGuessAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, gameType])
  @@index([userId])
  @@index([gameType])
  @@index([wins])
  @@index([userId, gameType, wins])
}

// =============================================================================
// USER & AUTHENTICATION (Better Auth compatible)
// =============================================================================

model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  role          String    @default("user")
  banned        Boolean?
  banReason     String?
  banExpires    DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Auth relationships
  accounts Account[]
  sessions Session[]

  // Game relationships
  gameStats    GameStats[]
  gameSessions GameSession[]

  @@index([email])
  @@index([role])
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@index([userId])
}

model Session {
  id             String    @id @default(cuid())
  userId         String
  token          String    @unique
  expiresAt      DateTime
  ipAddress      String?
  userAgent      String?
  impersonatedBy String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@index([expiresAt])
}

// =============================================================================
// CONTENT MODELS
// =============================================================================

model Carousel {
  id            Int    @id @default(autoincrement())
  alt           String
  mobileSource  String
  desktopSource String
  order         Int    @default(0)

  @@index([order])
}

model Committee {
  id     Int     @id @default(autoincrement())
  role   String
  source String?
  name   String

  @@index([role])
}

model Image {
  id              Int      @id @default(autoincrement())
  alt             String
  category        String
  year            Int
  source          String
  createdAt       DateTime @default(now())
  thumbnailSource String

  @@index([category])
  @@index([year])
  @@index([category, year])
}

model Event {
  id                 Int      @id @default(autoincrement())
  title              String
  description        String
  location           String
  date               DateTime
  color              String
  is_regular_session Boolean
  session_count      Int?

  @@index([date])
}

model Manga {
  id          Int     @id @default(autoincrement())
  title       String
  author      String
  volume      Int
  borrowed_by String?
  source      String
  genres      Genre[] @relation("GenreToManga")

  @@index([title])
  @@index([author])
}

model AnimeCard {
  id             Int     @id @default(autoincrement())
  title          String
  episode        String
  source         String
  mal_link       String
  total_episodes Int
  show_type      String
  studio         String
  genres         Genre[] @relation("AnimeCardToGenre")

  @@index([title])
  @@index([studio])
}
